import { Tree, formatFiles } from '@nx/devkit';
import * as path from 'path';
import * as fs from 'fs';
import * as prettier from 'prettier';
import * as stylelint from 'stylelint'; // Reverted to original import
import * as tokens from '../../../packages/components/src/theme/tokens'; // Direct import

// Helper function to convert camelCase to kebab-case
function kebabCase(str) {
  // Convert camelCase to kebab-case (e.g., fontSize -> font-size)
  str = str.replace(/([a-z0-9]|(?=[A-Z]))([A-Z])/g, '$1-$2');
  // Insert a dash before a number if it's preceded by a letter (e.g., gray10 -> gray-10)
  str = str.replace(/([a-z])(\d+)/g, '$1-$2');
  return str.toLowerCase();
}

export default async function (tree: Tree, schema: any) {
  const outputPath = path.resolve(
    tree.root,
    'packages/components/src/theme/theme.css',
  );

  // Dynamically get the names of exported constants from the tokens module
  const exportedConstNames = Object.keys(tokens);

  // The tokens object is now directly available via the import
  // No need for fs.readFileSync, eval, or related string manipulations


  // Updated comment for generated file
  let cssOutput = '/* THIS FILE IS AUTOGENERATED FROM tokens.ts. DO NOT EDIT MANUALLY. */\n\n:root {\n';
  const collectedCssVars = new Set(); // To store generated CSS variable names

  // Helper to format values for CSS
  function formatCssValue(value, cssVarName) {
    if (typeof value === 'number') {
      // Handle specific cases where numbers should be unitless
      if (cssVarName.startsWith('--z-index-') || cssVarName.startsWith('--typography-weight-')) {
        return value;
      }
      // If it's a number and not a special case, assume it needs 'px' or 'rem' if not already a string with unit
      // For now, if it's a number and not unitless, we'll assume it's a pixel value.
      // This is a simplification and might need more sophisticated logic if token values change.
      return `${value}px`; // Default to px for numbers if no specific unit is implied
    }
    // Handle font-family quoting
    if (cssVarName === '--typography-font-family' && typeof value === 'string' && value[0] !== "'" && value[0] !== '"') {
      return `'${value}'`;
    }

    // New rule: Wrap breakpoint media queries in quotes if they are strings and start with '('
    if (cssVarName.startsWith('--breakpoint-') && typeof value === 'string' && value.startsWith('(')) {
      return `'${value.replace(/"/g, '')}'`;
    }
    return value;
  }

  // Helper to process token objects
  function processTokens(obj, prefix = '') {
    for (const key in obj) {
      const value = obj[key];
      const cssVarName = `--${prefix}${kebabCase(key)}`;

      if (typeof value === 'object' && value !== null) {
        // Recursively process nested objects
        processTokens(value, `${prefix}${kebabCase(key)}-`);
      } else {
        // Directly add simple values
        let processedValue = formatCssValue(value, cssVarName);

        cssOutput += `  ${cssVarName}: ${processedValue};\n`;
        collectedCssVars.add(cssVarName); // Add to set
      }
    }
  }

  // Process each top-level export from tokens.ts dynamically
  for (const constName of exportedConstNames) {
    let prefix = '';
    switch (constName) {
      case 'baseColors':
        prefix = 'color-';
        break;
      case 'typography':
        prefix = 'typography-';
        break;
      case 'spacing':
        prefix = 'spacing-';
        break;
      case 'states':
        prefix = 'state-';
        break;
      case 'transitions':
        prefix = 'transition-';
        break;
      case 'semantic':
        prefix = 'semantic-';
        break;
      case 'zIndex':
        prefix = 'z-index-';
        break;
      case 'windowSizes':
        prefix = 'window-size-';
        break;
      case 'breakpoints':
        prefix = 'breakpoint-';
        break;
      case 'sizing':
        prefix = 'size-';
        break;
      default:
        prefix = `${kebabCase(constName)}-`;
        break;
    }
    processTokens(tokens[constName], prefix);
  }

  cssOutput += '}\n';

  const prettierConfig = await prettier.resolveConfig(process.cwd());
  const formattedCssOutput = await prettier.format(cssOutput, { ...prettierConfig, parser: 'css', singleQuote: true }); // Explicitly set singleQuote
  try {
    const lintResult = await stylelint.lint({
      code: formattedCssOutput,
      config: {
        extends: 'stylelint-config-standard', // Or your project's stylelint config
      },
      formatter: 'string',
    });

    if (lintResult.errored) {
      console.error('\n--- Stylelint Errors in generated theme.css ---\n');
      console.error(lintResult.output);
      console.error('\n---------------------------------------------\n');
      throw new Error('Generated theme.css contains Stylelint errors.');
    } else if (lintResult.results[0].warnings.length > 0) {
      console.warn('\n--- Stylelint Warnings in generated theme.css ---\n');
      console.warn(lintResult.output);
      console.warn('\n---------------------------------------------\n');
    }
  } catch (e) {
    console.error('Error during Stylelint validation:', e);
    throw e; // Re-throw to indicate failure
  }

  fs.writeFileSync(outputPath, formattedCssOutput, 'utf8');
  console.log('theme.css generated successfully!');

  // Log collected CSS variable names for verification
  console.log('\n--- Collected CSS Variables from tokens.ts ---\n');
  console.log(Array.from(collectedCssVars).sort().join('\n'));
  console.log('---------------------------------------------\n');

  await formatFiles(tree);
}