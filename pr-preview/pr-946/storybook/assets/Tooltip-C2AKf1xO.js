import{h as I,e as s,r as i,j as x}from"./iframe-Dme4aFdT.js";import{c as L}from"./clsx-Ciqy0D92.js";import{a as M,b as B,c as H,d as F,e as U,f as j,$ as k}from"./OverlayArrow-Clz9TAVy.js";import{b as T,e as z,k as K,$ as Y,a as G}from"./utils-RWkis8G9.js";import{d as q,$ as S,c as J,x as Q,A as X,C as Z}from"./useFocusRing-DWu_JWOd.js";import{$ as ee}from"./index-C7JOf_RQ.js";const O=s.createContext(null);function te(e){let{children:o}=e,t=i.useContext(O),[r,d]=i.useState(0),l=i.useMemo(()=>({parent:t,modalCount:r,addModal(){d(n=>n+1),t&&t.addModal()},removeModal(){d(n=>n-1),t&&t.removeModal()}}),[t,r]);return s.createElement(O.Provider,{value:l},o)}function oe(){let e=i.useContext(O);return{modalProviderProps:{"aria-hidden":e&&e.modalCount>0?!0:void 0}}}function ae(e){let{modalProviderProps:o}=oe();return s.createElement("div",{"data-overlay-container":!0,...e,...o})}function ne(e){return s.createElement(te,null,s.createElement(ae,e))}function re(e){let o=I(),{portalContainer:t=o?null:document.body,...r}=e,{getContainer:d}=M();if(!e.portalContainer&&d&&(t=d()),s.useEffect(()=>{if(t?.closest("[data-overlay-container]"))throw new Error("An OverlayContainer must not be inside another container. Please change the portalContainer prop.")},[t]),!t)return null;let l=s.createElement(ne,r);return ee.createPortal(l,t)}function le(e,o){let t=q(e,{labelable:!0}),{hoverProps:r}=S({onHoverStart:()=>o?.open(!0),onHoverEnd:()=>o?.close()});return{tooltipProps:T(t,r,{role:"tooltip"})}}function ie(e,o,t){let{isDisabled:r,trigger:d}=e,l=z(),n=i.useRef(!1),a=i.useRef(!1),u=()=>{(n.current||a.current)&&o.open(a.current)},p=g=>{!n.current&&!a.current&&o.close(g)};i.useEffect(()=>{let g=w=>{t&&t.current&&w.key==="Escape"&&(w.stopPropagation(),o.close(!0))};if(o.isOpen)return document.addEventListener("keydown",g,!0),()=>{document.removeEventListener("keydown",g,!0)}},[t,o]);let b=()=>{d!=="focus"&&(Q()==="pointer"?n.current=!0:n.current=!1,u())},$=()=>{d!=="focus"&&(a.current=!1,n.current=!1,p())},v=()=>{a.current=!1,n.current=!1,p(!0)},P=()=>{X()&&(a.current=!0,u())},c=()=>{a.current=!1,n.current=!1,p(!0)},{hoverProps:W}=S({isDisabled:r,onHoverStart:b,onHoverEnd:$}),{focusableProps:A}=J({isDisabled:r,onFocus:P,onBlur:c},t);return{triggerProps:{"aria-describedby":o.isOpen?l:void 0,...T(A,W,{onPointerDown:v,onKeyDown:v}),tabIndex:void 0},tooltipProps:{id:l}}}const de=1500,C=500;let m={},se=0,y=!1,f=null,h=null;function D(e={}){let{delay:o=de,closeDelay:t=C}=e,{isOpen:r,open:d,close:l}=B(e),n=i.useMemo(()=>`${++se}`,[]),a=i.useRef(null),u=i.useRef(l),p=()=>{m[n]=v},b=()=>{for(let c in m)c!==n&&(m[c](!0),delete m[c])},$=()=>{a.current&&clearTimeout(a.current),a.current=null,b(),p(),y=!0,d(),f&&(clearTimeout(f),f=null),h&&(clearTimeout(h),h=null)},v=c=>{c||t<=0?(a.current&&clearTimeout(a.current),a.current=null,u.current()):a.current||(a.current=setTimeout(()=>{a.current=null,u.current()},t)),f&&(clearTimeout(f),f=null),y&&(h&&clearTimeout(h),h=setTimeout(()=>{delete m[n],h=null,y=!1},Math.max(C,t)))},P=()=>{b(),p(),!r&&!f&&!y?f=setTimeout(()=>{f=null,y=!0,$()},o):r||$()};return i.useEffect(()=>{u.current=l},[l]),i.useEffect(()=>()=>{a.current&&clearTimeout(a.current),m[n]&&delete m[n]},[n]),{isOpen:r,open:c=>{!c&&o>0&&!a.current?P():$()},close:v}}const E=i.createContext(null),N=i.createContext(null);function ue(e){let o=D(e),t=i.useRef(null),{triggerProps:r,tooltipProps:d}=ie(e,o,t);return s.createElement(K,{values:[[E,o],[N,{...d,triggerRef:t}]]},s.createElement(Z,{...r,ref:t},e.children))}const ce=i.forwardRef(function({UNSTABLE_portalContainer:o,...t},r){[t,r]=Y(t,r,N);let d=i.useContext(E),l=D(t),n=t.isOpen!=null||t.defaultOpen!=null||!d?l:d,a=H(r,n.isOpen)||t.isExiting||!1;return!n.isOpen&&!a?null:s.createElement(re,{portalContainer:o},s.createElement(fe,{...t,tooltipRef:r,isExiting:a}))});function fe(e){let o=i.useContext(E),t=i.useRef(null),{overlayProps:r,arrowProps:d,placement:l,triggerAnchorPoint:n}=F({placement:e.placement||"top",targetRef:e.triggerRef,overlayRef:e.tooltipRef,arrowRef:t,offset:e.offset,crossOffset:e.crossOffset,isOpen:o.isOpen,arrowBoundaryOffset:e.arrowBoundaryOffset,shouldFlip:e.shouldFlip,containerPadding:e.containerPadding,onClose:()=>o.close(!0)}),a=U(e.tooltipRef,!!l)||e.isEntering||!1,u=G({...e,defaultClassName:"react-aria-Tooltip",values:{placement:l,isEntering:a,isExiting:e.isExiting,state:o}});e=T(e,r);let{tooltipProps:p}=le(e,o),b=q(e,{global:!0});return s.createElement("div",{...T(b,u,p),ref:e.tooltipRef,style:{...r.style,"--trigger-anchor-point":n?`${n.x}px ${n.y}px`:void 0,...u.style},"data-placement":l??void 0,"data-entering":a||void 0,"data-exiting":e.isExiting||void 0},s.createElement(j.Provider,{value:{...d,placement:l,ref:t}},u.children))}const pe="_tooltip_1nthz_1",me="_arrow_1nthz_18",_={tooltip:pe,arrow:me};function R({children:e,className:o,...t}){return x.jsxs(ce,{className:L(_.tooltip,o),...t,children:[x.jsx(k,{className:_.arrow,children:x.jsx("svg",{width:8,height:8,viewBox:"0 0 8 8",children:x.jsx("path",{d:"M0 0 L4 4 L8 0"})})}),e]})}function V({children:e,delay:o=0,...t}){return x.jsx(ue,{delay:o,...t,children:e})}try{R.displayName="Tooltip",R.__docgenInfo={description:"",displayName:"Tooltip",props:{className:{defaultValue:null,description:"The CSS [className](https://developer.mozilla.org/en-US/docs/Web/API/Element/className) for the element. A function may be provided to compute the class based on component state.",name:"className",required:!1,type:{name:"ClassNameOrFunction<TooltipRenderProps>"}},style:{defaultValue:null,description:"The inline [style](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style) for the element. A function may be provided to compute the style based on component state.",name:"style",required:!1,type:{name:"StyleOrFunction<TooltipRenderProps>"}},isOpen:{defaultValue:null,description:"Whether the element is rendered.",name:"isOpen",required:!1,type:{name:"boolean"}},defaultOpen:{defaultValue:null,description:"Whether the overlay is open by default (uncontrolled).",name:"defaultOpen",required:!1,type:{name:"boolean"}},onOpenChange:{defaultValue:null,description:"Handler that is called when the overlay's open state changes.",name:"onOpenChange",required:!1,type:{name:"((isOpen: boolean) => void)"}},offset:{defaultValue:{value:"0"},description:`The additional offset applied along the main axis between the element and its
anchor element.`,name:"offset",required:!1,type:{name:"number"}},isEntering:{defaultValue:null,description:"Whether the tooltip is currently performing an entry animation.",name:"isEntering",required:!1,type:{name:"boolean"}},isExiting:{defaultValue:null,description:"Whether the tooltip is currently performing an exit animation.",name:"isExiting",required:!1,type:{name:"boolean"}},UNSTABLE_portalContainer:{defaultValue:{value:"document.body"},description:`The container element in which the overlay portal will be placed. This may have unknown behavior depending on where it is portalled to.
@deprecated - Use a parent UNSAFE_PortalProvider to set your portal container instead.`,name:"UNSTABLE_portalContainer",required:!1,type:{name:"Element"}},placement:{defaultValue:{value:"'top'"},description:"The placement of the tooltip with respect to the trigger.",name:"placement",required:!1,type:{name:"enum",value:[{value:'"left"'},{value:'"right"'},{value:'"start"'},{value:'"end"'},{value:'"top"'},{value:'"bottom"'},{value:'"bottom left"'},{value:'"bottom right"'},{value:'"bottom start"'},{value:'"bottom end"'},{value:'"top left"'},{value:'"top right"'},{value:'"top start"'},{value:'"top end"'},{value:'"left top"'},{value:'"left bottom"'},{value:'"start top"'},{value:'"start bottom"'},{value:'"right top"'},{value:'"right bottom"'},{value:'"end top"'},{value:'"end bottom"'}]}},containerPadding:{defaultValue:{value:"12"},description:`The placement padding that should be applied between the element and its
surrounding container.`,name:"containerPadding",required:!1,type:{name:"number"}},crossOffset:{defaultValue:{value:"0"},description:`The additional offset applied along the cross axis between the element and its
anchor element.`,name:"crossOffset",required:!1,type:{name:"number"}},shouldFlip:{defaultValue:{value:"true"},description:`Whether the element should flip its orientation (e.g. top to bottom or left to right) when
there is insufficient room for it to render completely.`,name:"shouldFlip",required:!1,type:{name:"boolean"}},triggerRef:{defaultValue:null,description:`The ref for the element which the tooltip positions itself with respect to.

When used within a TooltipTrigger this is set automatically. It is only required when used standalone.`,name:"triggerRef",required:!1,type:{name:"RefObject<Element | null>"}},arrowBoundaryOffset:{defaultValue:{value:"0"},description:"The minimum distance the arrow's edge should be from the edge of the overlay element.",name:"arrowBoundaryOffset",required:!1,type:{name:"number"}}}}}catch{}try{V.displayName="TooltipTrigger",V.__docgenInfo={description:"",displayName:"TooltipTrigger",props:{isDisabled:{defaultValue:null,description:"Whether the tooltip should be disabled, independent from the trigger.",name:"isDisabled",required:!1,type:{name:"boolean"}},delay:{defaultValue:{value:"0"},description:"The delay time for the tooltip to show up. [See guidelines](https://spectrum.adobe.com/page/tooltip/#Immediate-or-delayed-appearance).",name:"delay",required:!1,type:{name:"number"}},closeDelay:{defaultValue:{value:"500"},description:"The delay time for the tooltip to close. [See guidelines](https://spectrum.adobe.com/page/tooltip/#Warmup-and-cooldown).",name:"closeDelay",required:!1,type:{name:"number"}},trigger:{defaultValue:{value:"'hover'"},description:"By default, opens for both focus and hover. Can be made to open only for focus.",name:"trigger",required:!1,type:{name:"enum",value:[{value:'"focus"'},{value:'"hover"'}]}},isOpen:{defaultValue:null,description:"Whether the element is rendered.",name:"isOpen",required:!1,type:{name:"boolean"}},defaultOpen:{defaultValue:null,description:"Whether the overlay is open by default (uncontrolled).",name:"defaultOpen",required:!1,type:{name:"boolean"}},onOpenChange:{defaultValue:null,description:"Handler that is called when the overlay's open state changes.",name:"onOpenChange",required:!1,type:{name:"((isOpen: boolean) => void)"}}}}}catch{}export{V as T,R as a};
