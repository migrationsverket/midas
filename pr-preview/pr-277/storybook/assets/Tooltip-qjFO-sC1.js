import{j as y}from"./jsx-runtime-DtgEGaVE.js";import{$ as A,b as W,c as j,d as B,e as H,f as V}from"./OverlayArrow-t3ozUHtu.js";import{e as k,p as q,a as N,d as P,j as U,n as F,y as z,I as K,C as Y,L as G,$ as J,l as Q,c as X}from"./useFocusable-CksQMUge.js";import{R as c,r as a}from"./index-BbAIUH2N.js";import{M as Z}from"./index-i7ZvCR4f.js";const E=c.createContext(null);function ee(e){let{children:r}=e,t=a.useContext(E),[l,i]=a.useState(0),s=a.useMemo(()=>({parent:t,modalCount:l,addModal(){i(n=>n+1),t&&t.addModal()},removeModal(){i(n=>n-1),t&&t.removeModal()}}),[t,l]);return c.createElement(E.Provider,{value:s},r)}function te(){let e=a.useContext(E);return{modalProviderProps:{"aria-hidden":e&&e.modalCount>0?!0:void 0}}}function re(e){let{modalProviderProps:r}=te();return c.createElement("div",{"data-overlay-container":!0,...e,...r})}function oe(e){return c.createElement(ee,null,c.createElement(re,e))}function ne(e){let r=k(),{portalContainer:t=r?null:document.body,...l}=e;if(c.useEffect(()=>{if(t!=null&&t.closest("[data-overlay-container]"))throw new Error("An OverlayContainer must not be inside another container. Please change the portalContainer prop.")},[t]),!t)return null;let i=c.createElement(oe,l);return Z.createPortal(i,t)}function le(e,r){let t=q(e,{labelable:!0}),{hoverProps:l}=N({onHoverStart:()=>r==null?void 0:r.open(!0),onHoverEnd:()=>r==null?void 0:r.close()});return{tooltipProps:P(t,l,{role:"tooltip"})}}function ae(e,r,t){let{isDisabled:l,trigger:i}=e,s=U(),n=a.useRef(!1),o=a.useRef(!1),f=()=>{(n.current||o.current)&&r.open(o.current)},d=x=>{!n.current&&!o.current&&r.close(x)};a.useEffect(()=>{let x=C=>{t&&t.current&&C.key==="Escape"&&(C.stopPropagation(),r.close(!0))};if(r.isOpen)return document.addEventListener("keydown",x,!0),()=>{document.removeEventListener("keydown",x,!0)}},[t,r]);let b=()=>{i!=="focus"&&(z()==="pointer"?n.current=!0:n.current=!1,f())},h=()=>{i!=="focus"&&(o.current=!1,n.current=!1,d())},g=()=>{o.current=!1,n.current=!1,d(!0)},T=()=>{K()&&(o.current=!0,f())},u=()=>{o.current=!1,n.current=!1,d(!0)},{hoverProps:M}=N({isDisabled:l,onHoverStart:b,onHoverEnd:h}),{focusableProps:D}=F({isDisabled:l,onFocus:T,onBlur:u},t);return{triggerProps:{"aria-describedby":r.isOpen?s:void 0,...P(D,M,{onPointerDown:g,onKeyDown:g})},tooltipProps:{id:s}}}const ie=1500,O=500;let $={},se=0,v=!1,p=null,m=null;function L(e={}){let{delay:r=ie,closeDelay:t=O}=e,{isOpen:l,open:i,close:s}=A(e),n=a.useMemo(()=>`${++se}`,[]),o=a.useRef(null),f=a.useRef(s),d=()=>{$[n]=g},b=()=>{for(let u in $)u!==n&&($[u](!0),delete $[u])},h=()=>{o.current&&clearTimeout(o.current),o.current=null,b(),d(),v=!0,i(),p&&(clearTimeout(p),p=null),m&&(clearTimeout(m),m=null)},g=u=>{u||t<=0?(o.current&&clearTimeout(o.current),o.current=null,f.current()):o.current||(o.current=setTimeout(()=>{o.current=null,f.current()},t)),p&&(clearTimeout(p),p=null),v&&(m&&clearTimeout(m),m=setTimeout(()=>{delete $[n],m=null,v=!1},Math.max(O,t)))},T=()=>{b(),d(),!l&&!p&&!v?p=setTimeout(()=>{p=null,v=!0,h()},r):l||h()};return a.useEffect(()=>{f.current=s},[s]),a.useEffect(()=>()=>{o.current&&clearTimeout(o.current),$[n]&&delete $[n]},[n]),{isOpen:l,open:u=>{!u&&r>0&&!o.current?T():h()},close:g}}const w=a.createContext(null),I=a.createContext(null);function ce(e){let r=L(e),t=a.useRef(null),{triggerProps:l,tooltipProps:i}=ae(e,r,t);return c.createElement(Y,{values:[[w,r],[I,{...i,triggerRef:t}]]},c.createElement(G,{...l,ref:t},e.children))}const de=a.forwardRef(function({UNSTABLE_portalContainer:r,...t},l){[t,l]=J(t,l,I);let i=a.useContext(w),s=L(t),n=t.isOpen!=null||t.defaultOpen!=null||!i?s:i,o=W(l,n.isOpen)||t.isExiting||!1;return!n.isOpen&&!o?null:c.createElement(ne,{portalContainer:r},c.createElement(ue,{...t,tooltipRef:l,isExiting:o}))});function ue(e){let r=a.useContext(w),t=a.useRef(null),[l,i]=a.useState(0);Q(()=>{t.current&&r.isOpen&&i(t.current.getBoundingClientRect().width)},[r.isOpen,t]);let{overlayProps:s,arrowProps:n,placement:o}=j({placement:e.placement||"top",targetRef:e.triggerRef,overlayRef:e.tooltipRef,offset:e.offset,crossOffset:e.crossOffset,isOpen:r.isOpen,arrowSize:l,arrowBoundaryOffset:e.arrowBoundaryOffset,shouldFlip:e.shouldFlip,onClose:()=>r.close(!0)}),f=B(e.tooltipRef,!!o)||e.isEntering||!1,d=X({...e,defaultClassName:"react-aria-Tooltip",values:{placement:o,isEntering:f,isExiting:e.isExiting,state:r}});e=P(e,s);let{tooltipProps:b}=le(e,r);return c.createElement("div",{...b,ref:e.tooltipRef,...d,style:{...s.style,...d.style},"data-placement":o??void 0,"data-entering":f||void 0,"data-exiting":e.isExiting||void 0},c.createElement(H.Provider,{value:{...n,placement:o,ref:t}},d.children))}const fe='"../theme/tokens.css"',pe='"Inter", sans-serif',$e="#1f1f1f",me="_tooltip_m1a8t_4",be="_arrow_m1a8t_17",_={tokens:fe,display:pe,gray150:$e,tooltip:me,arrow:be};function R({children:e,placement:r,...t}){return y.jsxs(de,{className:_.tooltip,placement:r,...t,children:[y.jsx(V,{className:_.arrow,children:y.jsx("svg",{width:8,height:8,viewBox:"0 0 8 8",children:y.jsx("path",{d:"M0 0 L4 4 L8 0"})})}),e]})}function S({children:e,delay:r=0,...t}){return y.jsx(ce,{delay:r,...t,children:e})}try{R.displayName="Tooltip",R.__docgenInfo={description:"",displayName:"Tooltip",props:{placement:{defaultValue:null,description:"The placement of the tooltip with respect to the trigger.",name:"placement",required:!1,type:{name:"enum",value:[{value:'"left"'},{value:'"right"'},{value:'"top"'},{value:'"bottom"'}]}},className:{defaultValue:null,description:"The CSS [className](https://developer.mozilla.org/en-US/docs/Web/API/Element/className) for the element. A function may be provided to compute the class based on component state.",name:"className",required:!1,type:{name:"string | ((values: TooltipRenderProps & { defaultClassName: string; }) => string)"}},style:{defaultValue:null,description:"The inline [style](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style) for the element. A function may be provided to compute the style based on component state.",name:"style",required:!1,type:{name:"CSSProperties | ((values: TooltipRenderProps & { defaultStyle: CSSProperties; }) => CSSProperties)"}},triggerRef:{defaultValue:null,description:`The ref for the element which the tooltip positions itself with respect to.

When used within a TooltipTrigger this is set automatically. It is only required when used standalone.`,name:"triggerRef",required:!1,type:{name:"RefObject<Element>"}},isEntering:{defaultValue:null,description:"Whether the tooltip is currently performing an entry animation.",name:"isEntering",required:!1,type:{name:"boolean"}},isExiting:{defaultValue:null,description:"Whether the tooltip is currently performing an exit animation.",name:"isExiting",required:!1,type:{name:"boolean"}},UNSTABLE_portalContainer:{defaultValue:{value:"document.body"},description:"The container element in which the overlay portal will be placed. This may have unknown behavior depending on where it is portalled to.",name:"UNSTABLE_portalContainer",required:!1,type:{name:"Element"}}}}}catch{}try{S.displayName="TooltipTrigger",S.__docgenInfo={description:"",displayName:"TooltipTrigger",props:{}}}catch{}export{R as T,S as a};
