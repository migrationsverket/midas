// This script will generate theme.css from tokens.ts
// It will be placed in /tools/

const fs = require('fs');
const path = require('path');

const tokensTsPath = path.resolve(__dirname, '../packages/components/src/theme/tokens.ts');
const outputPath = path.resolve(__dirname, '../packages/components/src/theme/theme.css');

try {
    let tokensContent = fs.readFileSync(tokensTsPath, 'utf8');

    // Remove 'export const' and replace with 'var' for eval
    tokensContent = tokensContent.replace(/export const /g, 'var ');

    // Wrap in an IIFE to create a scope and capture variables
    const evalString = `
        (function() {
            ${tokensContent}
            return {
                baseColors,
                typography,
                spacing,
                states,
                transitions,
                windowSizes,
                breakpoints,
                semantic,
                zIndex
            };
        })();
    `;

    // Evaluate the string to get the token objects
    const tokens = eval(evalString);

    // Updated comment for generated file
    let cssOutput = '/* THIS FILE IS AUTOGENERATED FROM tokens.ts. DO NOT EDIT MANUALLY. */\n\n:root {\n';
    const collectedCssVars = new Set(); // To store generated CSS variable names

    // Helper to process token objects
    function processTokens(obj, prefix = '') {
        for (const key in obj) {
            const value = obj[key];
            const cssVarName = `--${prefix}${kebabCase(key)}`;

            if (typeof value === 'object' && value !== null) {
                // Recursively process nested objects
                processTokens(value, `${prefix}${kebabCase(key)}-`);
            } else {
                // Directly add simple values
                cssOutput += `  ${cssVarName}: ${value};\n`;
                collectedCssVars.add(cssVarName); // Add to set
            }
        }
    }

    // Process each top-level export from tokens.ts
    processTokens(tokens.baseColors, 'color-');
    processTokens(tokens.typography, 'typography-');
    processTokens(tokens.spacing, 'spacing-');
    processTokens(tokens.states, 'state-');
    processTokens(tokens.transitions, 'transition-');
    processTokens(tokens.windowSizes, 'window-size-');
    processTokens(tokens.breakpoints, 'breakpoint-');
    processTokens(tokens.semantic, 'semantic-');
    processTokens(tokens.zIndex, 'z-index-');


    cssOutput += '}\n';

    fs.writeFileSync(outputPath, cssOutput, 'utf8');
    console.log('theme.css generated successfully!');

    // Log collected CSS variable names for verification
    console.log('\n--- Collected CSS Variables from tokens.ts ---\n');
    console.log(Array.from(collectedCssVars).sort().join('\n'));
    console.log('---------------------------------------------\n');

} catch (error) {
    console.error('Error generating theme.css:', error);
} 

// Helper function to convert camelCase to kebab-case
function kebabCase(str) {
    // Convert camelCase to kebab-case (e.g., fontSize -> font-size)
    str = str.replace(/([a-z0-9]|(?=[A-Z]))([A-Z])/g, '$1-$2');
    // Insert a dash before a number if it's preceded by a letter (e.g., gray10 -> gray-10)
    str = str.replace(/([a-z])(\d+)/g, '$1-$2');
    return str.toLowerCase();
}
